#!/usr/bin/env bash

# execution template:
# ./method-maker ifStatic minVersion fullmethod

# result is generated in console. It can be copied and pasted into methods in class

# Examples of full methods, which can be given as strings:

# QByteArray QTextEncoder::fromUnicode(const QString &str)
# QFileSelector(QObject *parent = nullptr)
# void QProcess::setReadChannel(QProcess::ProcessChannel channel)
# int QProcess::execute(const QString &program, const QStringList &arguments) 
# void QProcess::setStandardErrorFile(const QString &fileName, QIODevice::OpenMode mode = Truncate)


# examples of execution
# Asterisks characters (*) have to be backslashed !!!

# ./method-maker true "" "const QChar QString::at(int position) const""
# ./method-maker true "5.10" "QChar QString::back() const"
# ./method-maker false "" "int QString::compare(const QStringRef &ref, Qt::CaseSensitivity cs = ...) const"



contentMain=$(echo "$3" | awk -F"(" '{print $1}') # everything before "(" character
contentArg="("$(echo "$3" | awk -F"(" '{print $2}') # everything after "(" character
ifStatic=$1
minVersion=$2
majorVersion="$(cut -d'.' -f1 <<< "$minVersion")"
minorVersion="$(cut -d'.' -f2 <<< "$minVersion")"
methodName=""
argList=""
method=""
ifFirstDefault= false
defaultsCount=0
OUTPUT_FILE="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )/method-maker-outputs.txt"

rm -rf $OUTPUT_FILE
touch $OUTPUT_FILE


# echo "contentMain is $contentMain"
# echo "contentArg is $contentArg" 


if [[ $contentMain =~ "::" ]]; then

    read -a strarr <<< "$contentMain"
    
    if [ ${#strarr[*]} -gt 1 ]; then    # greater than 1 means it must have separated by whitespaces 1) return type and 2) classname::methodname
    
       #echo "Use other function than mkCtor"
       
       methodName="$(sed 's/.*:://' <<< "${strarr[1]}")"
       #echo "Method name is $methodName"
       
       if [ $ifStatic == true ]; then
           method="static-method"
       elif [ `echo "$3" | awk '{print $NF}'` == "const" ]; then
           method="const-method"
       else     
           method="regular-method"
       fi
       
    else
       #echo "Use mkCtor function"
       method="constructor-method"
    fi
    
else
     #echo "Use mkCtor function"
     method="constructor-method"
fi


#echo "It's $method"

afterChar=${contentArg#*(}
argList=${afterChar%)*}

#echo "Parameters list is $argList"


# https://stackoverflow.com/questions/369758/how-to-trim-whitespace-from-a-bash-variable
trim() {
    local var="$*"
    # remove leading whitespace characters
    var="${var#"${var%%[![:space:]]*}"}" 
    echo -e "$var"
}

trimBothSides() {
    local var="$*"
    # remove leading whitespace characters
    var="${var#"${var%%[![:space:]]*}"}"
    # remove trailing whitespace characters
    var="${var%"${var##*[![:space:]]}"}"   
    echo -n "$var"
}

IFS=',' read -r -a argArray <<< "$argList"


declare -a defaults_indexes

if [ ${#argArray[*]} -gt 0 ]; then

for index in "${!argArray[@]}"
do
    #echo "$index)"
    #trim "${argArray[index]}"
    
    if [[ "${argArray[index]}" =~ "=" ]]; then
       if [ $index -eq 0 ]; then
         ifFirstDefault=true
         defaultsCount=2
         defaults_indexes=("$index")
       else
         defaultsCount=$((defaultsCount+1))
         defaults_indexes=("${defaults_indexes[@]}" "$index")
       fi
    fi
done

fi

# gets type name from C++
return_type_for_haskell () {

case "$*" in

'bool')
  echo "boolT"
;;
'int')
  echo "intT"
;;
'std::string')
  echo "attach \"import Foreign.Hoppy.Generator.Std.String (c_string)\" in class file" >> $OUTPUT_FILE
  echo "c_string"
;;
'std::u16string')
  echo "word16T"
;;
'std::u32string')
  echo "word32T"
;;
'std::wstring')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (wchar_t)\" in class file" >> $OUTPUT_FILE
  echo "wchar_t"
;;
'uint')
  echo "uintT"
;;
'ulong')
  echo "ulongT"
;;
'qulonglong')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qulonglong)\" in class file" >> $OUTPUT_FILE
  echo "qulonglong"
;;
'qlonglong')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qlonglong)\" in class file" >> $OUTPUT_FILE
  echo "qlonglong"
;;
'ushort')
  echo "ushortT"
;;
'wchar_t')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (wchar_t)\" in class file" >> $OUTPUT_FILE
  echo "wchar_t"
;;
'char')
  echo "charT"
;;
'short')
  echo "shortT"
;;
'char16_t')
  echo "word16T"
;;
'char32_t')
  echo "word32T"
;;
'long')
  echo "longT"
;;
'long long')
  echo "llongT"
;;
'float')
  echo "floatT"
;;
'double')
  echo "doubleT"
;;
'void')
  echo "voidT"
;;
'uchar')
  echo "ucharT"
;;
'qreal')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qreal)\" in class file" >> $OUTPUT_FILE
  echo "qreal"
;;
'QFunctionPointer')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qfunctionpointer)\" in class file" >> $OUTPUT_FILE
  echo "qfunctionpointer"
;;
'QtMessageHandler')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qtmessagehandler)\" in class file" >> $OUTPUT_FILE
  echo "qtmessagehandler"
;;
'')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qint8)\" in class file" >> $OUTPUT_FILE
  echo "qint8"
;;
'')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qint16)\" in class file" >> $OUTPUT_FILE
  echo "qint16"
;;
'')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qint32)\" in class file" >> $OUTPUT_FILE
  echo "qint32"
;;
'')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qint64)\" in class file" >> $OUTPUT_FILE
  echo "qint64"
;;
'')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qintptr)\" in class file" >> $OUTPUT_FILE
  echo "qintptr"
;;
'')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qptrdiff)\" in class file" >> $OUTPUT_FILE
  echo "qptrdiff"
;;
'')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qsizetype)\" in class file" >> $OUTPUT_FILE
  echo "qsizetype"
;;
'')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (quint8)\" in class file" >> $OUTPUT_FILE
  echo "quint8"
;;
'')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (quint16)\" in class file" >> $OUTPUT_FILE
  echo "quint16"
;;
'')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (quint32)\" in class file" >> $OUTPUT_FILE
  echo "quint32"
;;
'')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (quint64)\" in class file" >> $OUTPUT_FILE
  echo "quint64"
;;
'')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (quintptr)\" in class file" >> $OUTPUT_FILE
  echo "quintptr"
;;
'')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (gluint)\" in class file" >> $OUTPUT_FILE
  echo "gluint"
;;
*) 
  if [[ "$*" =~ "::" ]] && [[ ! "$*" =~ "Qt::" ]]; then
    enumName="$(sed 's/.*:://' <<< "$*")"
    enumClass="$(sed 's/::.*//' <<< "$*")"
    echo "attach import enum e_$enumName from module file $enumClass.hs" >> $OUTPUT_FILE
    echo "It may be typedef too" >> $OUTPUT_FILE
    echo "In the case of import error, try \"bitspaceT bs_$enumName\"" >> $OUTPUT_FILE
    echo "enumT e_$enumName"
  elif [[ "$*" =~ "Qt::" ]] || [[ "$*" =~ "QtMsgType" ]]; then
    enumName="$(sed 's/.*:://' <<< "$*")"
    echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (e_$enumName)\" in class file" >> $OUTPUT_FILE
    echo "In the case of import error, try \"bitspaceT bs_$enumName\"" >> $OUTPUT_FILE
    echo "enumT e_$enumName"
  else
    if [[ "$*" == "..." ]]; then
       echo ""
    else
       echo "Don't forget to import class for $* or hide code with \"--\" comment characters (only if it's not current class type)" >> $OUTPUT_FILE
       echo "objT c_$*" # return then objT
    fi
  fi
;;
esac

}


return_type_for_haskell_2 () {

case "$*" in

'bool')
  echo "boolT"
;;
'int')
  echo "intT"
;;
'std::string')
  echo "attach \"import Foreign.Hoppy.Generator.Std.String (c_string)\" in class file" >> $OUTPUT_FILE
  echo "c_string"
;;
'std::u16string')
  echo "word16T"
;;
'std::u32string')
  echo "word32T"
;;
'std::wstring')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (wchar_t)\" in class file" >> $OUTPUT_FILE
  echo "wchar_t"
;;
'uint')
  echo "uintT"
;;
'ulong')
  echo "ulongT"
;;
'qulonglong')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qulonglong)\" in class file" >> $OUTPUT_FILE
  echo "qulonglong"
;;
'qlonglong')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qlonglong)\" in class file" >> $OUTPUT_FILE
  echo "qlonglong"
;;
'ushort')
  echo "ushortT"
;;
'wchar_t')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (wchar_t)\" in class file" >> $OUTPUT_FILE
  echo "wchar_t"
;;
'char')
  echo "charT"
;;
'short')
  echo "shortT"
;;
'char16_t')
  echo "word16T"
;;
'char32_t')
  echo "word32T"
;;
'long')
  echo "longT"
;;
'long long')
  echo "llongT"
;;
'float')
  echo "floatT"
;;
'double')
  echo "doubleT"
;;
'void')
  echo "voidT"
;;
'uchar')
  echo "ucharT"
;;
'qreal')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qreal)\" in class file" >> $OUTPUT_FILE
  echo "qreal"
;;
'QFunctionPointer')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qfunctionpointer)\" in class file" >> $OUTPUT_FILE
  echo "qfunctionpointer"
;;
'QtMessageHandler')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qtmessagehandler)\" in class file" >> $OUTPUT_FILE
  echo "qtmessagehandler"
;;
'')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qint8)\" in class file" >> $OUTPUT_FILE
  echo "qint8"
;;
'')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qint16)\" in class file" >> $OUTPUT_FILE
  echo "qint16"
;;
'')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qint32)\" in class file" >> $OUTPUT_FILE
  echo "qint32"
;;
'')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qint64)\" in class file" >> $OUTPUT_FILE
  echo "qint64"
;;
'')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qintptr)\" in class file" >> $OUTPUT_FILE
  echo "qintptr"
;;
'')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qptrdiff)\" in class file" >> $OUTPUT_FILE
  echo "qptrdiff"
;;
'')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qsizetype)\" in class file" >> $OUTPUT_FILE
  echo "qsizetype"
;;
'')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (quint8)\" in class file" >> $OUTPUT_FILE
  echo "quint8"
;;
'')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (quint16)\" in class file" >> $OUTPUT_FILE
  echo "quint16"
;;
'')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (quint32)\" in class file" >> $OUTPUT_FILE
  echo "quint32"
;;
'')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (quint64)\" in class file" >> $OUTPUT_FILE
  echo "quint64"
;;
'')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (quintptr)\" in class file" >> $OUTPUT_FILE
  echo "quintptr"
;;
'')
  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (gluint)\" in class file" >> $OUTPUT_FILE
  echo "gluint"
;;
*) 

  #if [ $(grep -o "::" <<<"$*" | wc -l) -gt 1 ]; then
  #  enumName="$(sed 's/.*:://' <<< "$*")"
  #  echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (e_$enumName)\" in class file" >> $OUTPUT_FILE
  #  echo "In the case of import error, try \"bitspaceT bs_$enumName\"" >> $OUTPUT_FILE
  #  echo "enumT e_$enumName"
  if [[ "$*" =~ "::" ]] && [[ ! "$*" =~ "Qt::" ]]; then
    enumName="$(sed 's/.*:://' <<< "$*")"
    enumClass="$(sed 's/::.*//' <<< "$*")"
    echo "attach import enum e_$enumName from module file $enumClass.hs" >> $OUTPUT_FILE
    echo "It may be typedef too" >> $OUTPUT_FILE
    echo "In the case of import error, try \"bitspaceT bs_$enumName\"" >> $OUTPUT_FILE
    echo "enumT e_$enumName"
  elif [[ "$*" =~ "Qt::" ]] || [[ "$*" =~ "QtMsgType" ]]; then
    enumName="$(sed 's/.*:://' <<< "$*")"
    echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (e_$enumName)\" in class file" >> $OUTPUT_FILE
    echo "In the case of import error, try \"bitspaceT bs_$enumName\"" >> $OUTPUT_FILE
    echo "enumT e_$enumName"
  else
    if [[ "$*" == "..." ]]; then
       echo ""
    else
       echo "Don't forget to import class for $* or hide code with \"--\" comment characters (only if it's not current class type)" >> $OUTPUT_FILE
       echo "objT c_$*" # return then objT
    fi
  fi
;;

esac

}



convert_arg_to_haskell () {

local argFromC="$*"

#echo "$argFromC"
argFromC=${argFromC/build-sdists/}
local result=""
ampersand='\&'
#echo "$argFromC"

if [[ $argFromC =~ '=' ]]; then
#   echo "There is \"=\" character" 
   argFromC=$(echo "$argFromC" | cut -f1 -d'=')
fi

if [[ $argFromC =~ $ampersand ]]; then
#   echo "There is \"&\" character" 
   argFromC=$(echo "$argFromC" | cut -f1 -d'&')
   result+="refT $ "
elif egrep -q "\*" <<< "$argFromC"; then
   #echo "There is \"*\" character" 
   argFromC=$(echo "$argFromC" | cut -f1 -d'\') # because asterisks have to be backlashed
   result+="ptrT $ "
fi

if [[ "$argFromC" =~ "const" ]]; then
#   echo "There is \"const\" word" 
   argFromC=${argFromC/const/}
   result+="constT $ "
fi


argFromC="$(trimBothSides $argFromC)"
#echo -n "Trimmed argument is $argFromC"
IFS=' '
read -a strarrr <<< "$argFromC"
    

if [ ${#strarrr[*]} -eq 1 ]; then # in other cases
  result+="$(return_type_for_haskell $argFromC $MESSAGES)"

elif [ ${#strarrr[*]} -eq 2 ]; then # in the case of enum
  result+="$(return_type_for_haskell ${strarrr[0]} $MESSAGES)"

fi

#echo "Created full parameter: $result"
echo "$result"

}


convert_arg_to_haskell_2 () {

local argFromC="$*"

argFromC=${argFromC/build-sdists/}
local result=""
ampersand='\&'
#echo "$argFromC"


if [[ $argFromC =~ $ampersand ]]; then
#   echo "There is \"&\" character" 
   argFromC=$(echo "$argFromC" | cut -f1 -d'&')
   result+="refT $ "
elif egrep -q "\*" <<< "$argFromC"; then
   #echo "There is \"*\" character" 
   argFromC=$(echo "$argFromC" | cut -f1 -d'\') # because asterisks have to be backlashed
   result+="ptrT $ "
fi

if [[ "$argFromC" =~ "const" ]]; then
#   echo "There is \"const\" word" 
   argFromC=${argFromC/const/}
   result+="constT $ "
fi

argFromC=$(echo $argFromC | sed 's/\S*::\S*$//g')


argFromC="$(trimBothSides $argFromC)"
#echo "Trimmed argument is | $argFromC |"
IFS=' '
read -a strarrr <<< "$argFromC"
    
    
if [ ${#strarrr[*]} -eq 1 ]; then # in other cases
  result+="$(return_type_for_haskell_2 $argFromC $MESSAGES)"
elif [ ${#strarrr[*]} -eq 2 ]; then # in the case of enum
  result+="$(return_type_for_haskell_2 ${strarrr[0]} $MESSAGES)"
fi

#echo "Created full parameter: $result"
echo "$result"

}


#echo "amount of defaults parameters: $defaultsCount" 
#if [[ $ifFirstDefault == true ]]; then echo "first parameter is the default one"; fi 



# list of default parameters indexes
create_def_args () {

mkMethodType="$1"
ifProp=$2

for index in "${!defaults_indexes[@]}"
do

if [ $index -eq 0 -a "${defaults_indexes[$index]}" -eq "0" ]; then

   if [ ! -z "$minVersion" ]; then
   
     if [ $ifProp == true ]; then
        echo "test (qtVersion >= [$majorVersion, $minorVersion]) $ $mkMethodType \"new\" []"
        echo "test (qtVersion >= [$majorVersion, $minorVersion]) $ $mkMethodType \"newWithArg1\" [`echo $(convert_arg_to_haskell ${argArray[0]})`]"
     elif [ $ifProp == false ]; then
        echo "test (qtVersion >= [$majorVersion, $minorVersion]) $ $mkMethodType' \"$methodName\" \"$methodName\" [] $ `echo $(convert_arg_to_haskell_2 $contentMain)`"
        echo "test (qtVersion >= [$majorVersion, $minorVersion]) $ $mkMethodType' \"$methodName\" \"${methodName}WithArg1\" [`echo $(convert_arg_to_haskell ${argArray[0]})`] $ `echo $(convert_arg_to_haskell_2 $contentMain)`"
     fi
     
   else
   
     if [ $ifProp == true ]; then
        echo "just $ $mkMethodType \"new\" []"
        echo "just $ $mkMethodType \"newWithArg1\" [`echo $(convert_arg_to_haskell ${argArray[0]})`]"
     elif [ $ifProp == false ]; then
        echo "just $ $mkMethodType' \"$methodName\" \"$methodName\" [] $ `echo $(convert_arg_to_haskell_2 $contentMain)`"
        echo "just $ $mkMethodType' \"$methodName\" \"${methodName}WithArg1\" [`echo $(convert_arg_to_haskell ${argArray[0]})`] $ `echo $(convert_arg_to_haskell_2 $contentMain)`"
     fi
     
   fi

else
    
    if [ ! -z "$minVersion" ]; then
       if [ $index -eq 0 ]; then ## add version without defaults and with first default with min version
    
         res1=""
         res2=""
         
         if [ $ifProp == true ]; then
             res1="test (qtVersion >= [$majorVersion, $minorVersion]) $ $mkMethodType \"new\" ["
             res2="test (qtVersion >= [$majorVersion, $minorVersion]) $ $mkMethodType \"newWithArg1\" ["
         elif [ $ifProp == false ]; then
             res1="test (qtVersion >= [$majorVersion, $minorVersion]) $ $mkMethodType' \"$methodName\" \"$methodName\" ["
             res2="test (qtVersion >= [$majorVersion, $minorVersion]) $ $mkMethodType' \"$methodName\" \"${methodName}WithArg1\" ["
         fi
         
         i=0
         
         while [ "$((defaults_indexes[0]))" -gt $i ] # first index of defaults has to be greater than indexes of non defaults parameters
         do
             res1+="`echo $(convert_arg_to_haskell ${argArray[$i]})`, "
             res2+="`echo $(convert_arg_to_haskell ${argArray[$i]})`, "
             i=$(( $i + 1 ))
            
            if [ "$((defaults_indexes[0]))" -eq $i ]; then
               res2+="`echo $(convert_arg_to_haskell ${argArray[$i]})`"
               res1="`echo $res1 | sed 's/\(.*\),/\1 /'`"
            fi
         done
         
         if [ $ifProp == true ]; then
            res1+="]"
            res2+="]"
         elif [ $ifProp == false ]; then
            res1+="] $ `echo $(convert_arg_to_haskell_2 $contentMain)`"
            res2+="] $ `echo $(convert_arg_to_haskell_2 $contentMain)`"
         fi
         
         echo "$res1"
         echo "$res2"
         
       else
       
         if [ $ifProp == true ]; then
           res2="test (qtVersion >= [$majorVersion, $minorVersion]) $ $mkMethodType \"newWithArg$((index + 1))\" ["
         elif [ $ifProp == false ]; then
           res2="test (qtVersion >= [$majorVersion, $minorVersion]) $ $mkMethodType' \"$methodName\" \"${methodName}WithArg$((index + 1))\" ["
         fi
         
         i=0
         
         while [ "$((defaults_indexes[$index]))" -gt $i ] # first index of defaults has to be greater than indexes of non defaults parameters
         do
            res2+="`echo $(convert_arg_to_haskell ${argArray[$i]})`, "
            i=$(( $i + 1 ))
            
            if [ "$((defaults_indexes[$index]))" -eq $i ]; then
               res2+="`echo $(convert_arg_to_haskell ${argArray[$i]})`"
            fi
         done
         
         if [ $ifProp == true ]; then
            res2+="]"
         elif [ $ifProp == false ]; then
            res2+="] $ `echo $(convert_arg_to_haskell_2 $contentMain)`"
         fi
         
         echo "$res2"
    
       fi
    
    else
       if [ $index -eq 0 ]; then ## add version without defaults and with first default with min version
    
         res1=""
         res2=""
    
         if [ $ifProp == true ]; then
         
           res1="just $ $mkMethodType \"new\" ["
           res2="just $ $mkMethodType \"newWithArg1\" ["
         
         elif [ $ifProp == false ]; then
         
           res1="just $ $mkMethodType' \"$methodName\" \"$methodName\" ["
           res2="just $ $mkMethodType' \"$methodName\" \"${methodName}WithArg1\" ["
         
         fi
         
         i=0
         
         while [ "$((defaults_indexes[0]))" -gt $i ] # first index of defaults has to be greater than indexes of non defaults parameters
         do
            res1+="`echo $(convert_arg_to_haskell ${argArray[$i]})`, "
            res2+="`echo $(convert_arg_to_haskell ${argArray[$i]})`, "
            i=$(( $i + 1 ))
            
            if [ "$((defaults_indexes[0]))" -eq $i ]; then
               res2+="`echo $(convert_arg_to_haskell ${argArray[$i]})`"
               res1=$(echo $res1 | sed 's/\(.*\), /\1 /')
            fi
         done
         
         if [ $ifProp == true ]; then
            res1+="]"
            res2+="]"
         elif [ $ifProp == false ]; then
            res1+="] $ `echo $(convert_arg_to_haskell_2 $contentMain)`"
            res2+="] $ `echo $(convert_arg_to_haskell_2 $contentMain)`"
         fi
         
         echo "$res1"
         echo "$res2"
         
       else
       
         if [ $ifProp == true ]; then
            res2="just $ $mkMethodType \"newWithArg$((index + 1))\" ["
         elif [ $ifProp == false ]; then
            res2="just $ $mkMethodType' \"$methodName\" \"${methodName}WithArg$((index + 1))\" ["
         fi
         
         i=0
         
         while [ "$((defaults_indexes[$index]))" -gt $i ] # first index of defaults has to be greater than indexes of non defaults parameters
         do
            res2+="`echo $(convert_arg_to_haskell ${argArray[$i]})`, "
            i=$(( $i + 1 ))
            
            if [ "$((defaults_indexes[$index]))" -eq $i ]; then
               res2+="`echo $(convert_arg_to_haskell ${argArray[$i]})`"
            fi
         done
         
         if [ $ifProp == true ]; then
            res2+="]"
         elif [ $ifProp == false ]; then
            res2+="] $ `echo $(convert_arg_to_haskell_2 $contentMain)`"
         fi
    
         echo "$res2"
    
       fi  
    fi
fi

done

}



create_args () {

local res=""

# list of parameters
for indexArg in "${!argArray[@]}"
do

  if [ $indexArg -gt 0 ]; then
     res+=", `echo $(convert_arg_to_haskell ${argArray[$indexArg]})`"
  else
     res+=`echo $(convert_arg_to_haskell ${argArray[$indexArg]})`
  fi

done

echo "$res"

}



case "$method" in

'static-method') 

    if [ $defaultsCount -gt 0 ]; then    
        echo "$(create_def_args "mkStaticMethod" false)"
    else
    
      if [ ! -z "$minVersion" ]; then
         echo "test (qtVersion >= [$majorVersion, $minorVersion]) $ mkStaticMethod \"$methodName\" [$(create_args)] $ `echo $(convert_arg_to_haskell_2 $contentMain)`"
      else
         echo "just $ mkStaticMethod \"$methodName\" [$(create_args)] $ `echo $(convert_arg_to_haskell_2 $contentMain)`"
      fi
      
    fi
    ;;
'regular-method')  

    if [ $defaultsCount -gt 0 ]; then
       echo "$(create_def_args "mkMethod" false)"
    else
    
      if [ ! -z "$minVersion" ]; then
         echo "test (qtVersion >= [$majorVersion, $minorVersion]) $ mkMethod \"$methodName\" [$(create_args)] $ `echo $(convert_arg_to_haskell_2 $contentMain)`"
      else
         echo "just $ mkMethod \"$methodName\" [$(create_args)] $ `echo $(convert_arg_to_haskell_2 $contentMain)`"
      fi    
      
    fi
    ;;
'const-method')  

    if [ $defaultsCount -gt 0 ]; then
      echo "$(create_def_args "mkConstMethod" false)"
    else
    
      if [ ! -z "$minVersion" ]; then
         echo "test (qtVersion >= [$majorVersion, $minorVersion]) $ mkConstMethod \"$methodName\" [$(create_args)] $ `echo $(convert_arg_to_haskell_2 $contentMain)`"
      else
         echo "just $ mkConstMethod \"$methodName\" [$(create_args)] $ `echo $(convert_arg_to_haskell_2 $contentMain)`"
      fi    
      
    fi
    ;;
'constructor-method') 

    if [ $defaultsCount -gt 0 ]; then
       echo "$(create_def_args "mkProp" true)"   
    else
      if [ ! -z "$minVersion" ]; then
         echo "test (qtVersion >= [$majorVersion, $minorVersion]) $ mkCtor \"new\" [$(create_args)]"
      else
         echo "just $ mkCtor \"new\" [$(create_args)]"
      fi    
    fi
   ;;
*) 
  echo "The method type is unknown"
   ;;
   
esac

echo ""
cat $OUTPUT_FILE
rm -rf $OUTPUT_FILE
