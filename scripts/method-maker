#!/usr/bin/env bash

# execution template:
# ./method-maker ifStatic minVersion fullmethod

# result is generated in console. It can be copied and pasted into methods in class

# Examples of full methods, which can be given as strings:

# QByteArray QTextEncoder::fromUnicode(const QString &str)
# QFileSelector(QObject *parent = nullptr)
# void QProcess::setReadChannel(QProcess::ProcessChannel channel)
# int QProcess::execute(const QString &program, const QStringList &arguments) 
# void QProcess::setStandardErrorFile(const QString &fileName, QIODevice::OpenMode mode = Truncate)

contentMain=$(echo "$3" | awk -F"(" '{print $1}') # everything before "(" character
contentArg="("$(echo "$3" | awk -F"(" '{print $2}') # everything after "(" character
ifStatic=$1
minVersion=$2
returnedType=""
methodName=""
argList=""
method=""
ifFirstDefault= false
defaultsCount=0


echo "contentMain is $contentMain"
echo "contentArg is $contentArg" 


if [[ $contentMain =~ "::" ]]; then

    read -a strarr <<< "$contentMain"
    
    if [ ${#strarr[*]} -gt 1 ]; then    # greater than 1 means it must have separated by whitespaces 1) return type and 2) classname::methodname
    
       echo "Use other function than mkCtor"
       
       returnedType="${strarr[0]}"
       
       echo "Return type is $returnedType"
       
       methodName="$(sed 's/.*:://' <<< "${strarr[1]}")"
       echo "Method name is $methodName"
       
       if [ $ifStatic == true ]; then
           method="static-method"
       elif [ `echo $contentArg | awk '{print $NF}'` == "const" ]; then
           method="const-method"
       else     
           method="regular-method"
       fi
       
    else
       echo "Use mkCtor function"
       method="constructor-method"
    fi
    
else
     echo "Use mkCtor function"
     method="constructor-method"
fi


echo "It's $method"

afterChar=${contentArg#*(}
argList=${afterChar%)*}

echo "Parameters list is $argList"


# https://stackoverflow.com/questions/369758/how-to-trim-whitespace-from-a-bash-variable
trim() {
    local var="$*"
    # remove leading whitespace characters
    var="${var#"${var%%[![:space:]]*}"}" 
    echo -e "$var"
}

trimBothSides() {
    local var="$*"
    # remove leading whitespace characters
    var="${var#"${var%%[![:space:]]*}"}"
    # remove trailing whitespace characters
    var="${var%"${var##*[![:space:]]}"}"   
    echo -n "$var"
}

IFS=',' read -r -a argArray <<< "$argList"


if [ ${#argArray[*]} -gt 0 ]; then

for index in "${!argArray[@]}"
do
    echo "$index)"
    trim "${argArray[index]}"
    
    if [[ "${argArray[index]}" =~ "=" ]]; then
       if [ $index -eq 0 ]; then
         ifFirstDefault=true
         defaultsCount=2
       else
         defaultsCount=$((defaultsCount+1))
       fi
    fi
done

fi

# gets type name from C++
return_type_for_haskell () {
case "$*" in
'bool')
  echo "boolT"
;;
'int')
  echo "intT"
;;
'std::string')
  #echo "attach \"import Foreign.Hoppy.Generator.Std.String (c_string)\" in class file"
  echo "c_string"
;;
'std::u16string')
  echo "-- TODO std::u16string"
;;
'std::u32string')
  echo "-- TODO std::u32string"
;;
'std::wstring')
  echo "-- TODO std::wstring"
;;
'uint')
  echo "uintT"
;;
'ulong')
  echo "ulongT"
;;
'qulonglong')
  #echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qulonglong)\" in class file"
  echo "qulonglong"
;;
'qlonglong')
  #echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qlonglong)\" in class file"
  echo "qlonglong"
;;
'ushort')
  echo "ushortT"
;;
'wchar_t')
  echo "-- TODO wchar_t"
;;
'char')
  echo "charT"
;;
'short')
  echo "shortT"
;;
'char16_t')
  echo "-- TODO char16_t"
;;
'char32_t')
  echo "-- TODO char32_t"
;;
'long')
  echo "longT"
;;
'qint64')
  echo "int64_t"
;;
'quint64')
  echo "uint64_t"
;;
'float')
  echo "floatT"
;;
'double')
  echo "doubleT"
;;
'void')
  echo "voidT"
;;
'uchar')
  echo "ucharT"
;;
'qreal')
  #echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qreal)\" in class file"
  echo "qreal"
;;
*) 
  if [[ "$*" =~ "::" ]]; then
    enumName="$(sed 's/.*:://' <<< "$*")"
    #echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (e_$enumName)\" in class file"
    #echo "In the case of import error, try \"bitspaceT bs_$enumName\""
    echo "enumT e_$enumName"
  else
    #echo "It's object"
    #echo "$*"
    echo "objT c_$*" # return then objT
  fi
;;
esac
}


return_type_for_haskell_2 () {
case "$*" in
'bool')
  echo "boolT"
;;
'int')
  echo "intT"
;;
'std::string')
  #echo "attach \"import Foreign.Hoppy.Generator.Std.String (c_string)\" in class file"
  echo "c_string"
;;
'std::u16string')
  echo "-- TODO std::u16string"
;;
'std::u32string')
  echo "-- TODO std::u32string"
;;
'std::wstring')
  echo "-- TODO std::wstring"
;;
'uint')
  echo "uintT"
;;
'ulong')
  echo "ulongT"
;;
'qulonglong')
  #echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qulonglong)\" in class file"
  echo "qulonglong"
;;
'qlonglong')
  #echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qlonglong)\" in class file"
  echo "qlonglong"
;;
'ushort')
  echo "ushortT"
;;
'wchar_t')
  echo "-- TODO wchar_t"
;;
'char')
  echo "charT"
;;
'short')
  echo "shortT"
;;
'char16_t')
  echo "-- TODO char16_t"
;;
'char32_t')
  echo "-- TODO char32_t"
;;
'long')
  echo "longT"
;;
'qint64')
  echo "int64_t"
;;
'quint64')
  echo "uint64_t"
;;
'float')
  echo "floatT"
;;
'double')
  echo "doubleT"
;;
'void')
  echo "voidT"
;;
'uchar')
  echo "ucharT"
;;
'qreal')
  #echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (qreal)\" in class file"
  echo "qreal"
;;
*) 
  if [ $(grep -o "::" <<<"$*" | wc -l) -gt 1 ]; then
    enumName="$(sed 's/.*:://' <<< "$*")"
    #echo "attach \"import Graphics.UI.Qtah.Generator.Interface.Core.Types (e_$enumName)\" in class file"
    #echo "In the case of import error, try \"bitspaceT bs_$enumName\""
    echo "enumT e_$enumName"
  else
    #echo "It's object"
    #echo "$*"
    echo "objT c_$*" # return then objT
  fi
;;
esac
}


convert_arg_to_haskell () {

local argFromC="$*"

#echo "$argFromC"
argFromC=${argFromC/build-sdists/}
local result=""
ampersand='\&'
#echo "$argFromC"

if [[ $argFromC =~ '=' ]]; then
#   echo "There is \"=\" character" 
   argFromC=$(echo "$argFromC" | cut -f1 -d'=')
fi

if [[ $argFromC =~ $ampersand ]]; then
#   echo "There is \"&\" character" 
   argFromC=$(echo "$argFromC" | cut -f1 -d'&')
   result+="refT $ "
elif egrep -q "\*" <<< "$argFromC"; then
   #echo "There is \"*\" character" 
   argFromC=$(echo "$argFromC" | cut -f1 -d'\') # because asterisks have to be backlashed
   result+="ptrT $ "
fi

if [[ "$argFromC" =~ "const" ]]; then
#   echo "There is \"const\" word" 
   argFromC=${argFromC/const/}
   result+="constT $ "
fi


argFromC="$(trimBothSides $argFromC)"
#echo "Trimmed argument is $argFromC"
IFS=' '
read -a strarrr <<< "$argFromC"
    
    
if [ ${#strarrr[*]} -eq 1 ]; then # in other cases
  result+="$(return_type_for_haskell $argFromC)"

elif [ ${#strarrr[*]} -eq 2 ]; then # in the case of enum
  result+="$(return_type_for_haskell ${argFromC[0]})"

fi

#echo "Created full parameter: $result"
echo "$result"

}


convert_arg_to_haskell_2 () {

local argFromC="$*"

argFromC=${argFromC/build-sdists/}
local result=""
ampersand='\&'
#echo "$argFromC"


if [[ $argFromC =~ $ampersand ]]; then
#   echo "There is \"&\" character" 
   argFromC=$(echo "$argFromC" | cut -f1 -d'&')
   result+="refT $ "
elif egrep -q "\*" <<< "$argFromC"; then
   #echo "There is \"*\" character" 
   argFromC=$(echo "$argFromC" | cut -f1 -d'\') # because asterisks have to be backlashed
   result+="ptrT $ "
fi

if [[ "$argFromC" =~ "const" ]]; then
#   echo "There is \"const\" word" 
   argFromC=${argFromC/const/}
   result+="constT $ "
fi

argFromC=$(echo $argFromC | sed 's/\S*::\S*//g')


argFromC="$(trimBothSides $argFromC)"
#echo "Trimmed argument is $argFromC"
IFS=' '
read -a strarrr <<< "$argFromC"
    
    
if [ ${#strarrr[*]} -eq 1 ]; then # in other cases
  result+="$(return_type_for_haskell_2 $argFromC)"

elif [ ${#strarrr[*]} -eq 2 ]; then # in the case of enum
  result+="$(return_type_for_haskell_2 ${argFromC[0]})"

fi

#echo "Created full parameter: $result"
echo "$result"

}


echo "amount of defaults parameters: $defaultsCount" 
if [[ $ifFirstDefault == true ]]; then echo "first parameter is the default one"; fi 


case "$method" in

'static-method')  
    
    if [ $defaultsCount -gt 0 ]; then
       if [[ $ifFirstDefault == true ]]; then
         if [ ! -z "$minVersion" ]; then
           majorVersion="$(cut -d'.' -f1 <<< "$minVersion")"
           minorVersion="$(cut -d'.' -f2 <<< "$minVersion")"

           echo "test (qtVersion >= [$majorVersion, $minorVersion]) $ mkStaticMethod' $methodName $methodName [] $ `echo $(convert_arg_to_haskell_2 $contentMain)`"
           echo "test (qtVersion >= [$majorVersion, $minorVersion]) $ mkStaticMethod' $methodName ${methodName}WithArg1 [`echo $(convert_arg_to_haskell ${argArray[0]})`] $ `echo $(convert_arg_to_haskell_2 $contentMain)`"
         else
           echo "just $ mkStaticMethod' $methodName $methodName [] $ `echo $(convert_arg_to_haskell_2 $contentMain)`"
           echo "just $ mkStaticMethod' $methodName ${methodName}WithArg1 [`echo $(convert_arg_to_haskell ${argArray[0]})`] $ `echo $(convert_arg_to_haskell_2 $contentMain)`"
         fi
       fi
       
    else
      if [ ! -z "$minVersion" ]; then
         majorVersion="$(cut -d'.' -f1 <<< "$minVersion")"
         minorVersion="$(cut -d'.' -f2 <<< "$minVersion")"
         echo "test (qtVersion >= [$majorVersion, $minorVersion]) $ mkStaticMethod $methodName [] $contentMain"
      else
         echo "just $ mkStaticMethod $methodName [] $contentMain"
      fi
    fi
    ;;
'regular-method')  

    if [ $defaultsCount -gt 0 ]; then
       if [[ $ifFirstDefault == true ]]; then
         majorVersion="$(cut -d'.' -f1 <<< "$minVersion")"
         minorVersion="$(cut -d'.' -f2 <<< "$minVersion")"
       fi
       
    else
      if [ ! -z "$minVersion" ]; then
         majorVersion="$(cut -d'.' -f1 <<< "$minVersion")"
         minorVersion="$(cut -d'.' -f2 <<< "$minVersion")"
         echo "test (qtVersion >= [$majorVersion, $minorVersion]) $ mkMethod $methodName [] $returnedType"
      else
         echo "just $ mkMethod $methodName [] $returnedType"
      fi    
    fi
    ;;
'const-method')  

    if [ $defaultsCount -gt 0 ]; then
       if [[ $ifFirstDefault == true ]]; then
         majorVersion="$(cut -d'.' -f1 <<< "$minVersion")"
         minorVersion="$(cut -d'.' -f2 <<< "$minVersion")"
       fi

    else
      if [ ! -z "$minVersion" ]; then
         majorVersion="$(cut -d'.' -f1 <<< "$minVersion")"
         minorVersion="$(cut -d'.' -f2 <<< "$minVersion")"
         echo "test (qtVersion >= [$majorVersion, $minorVersion]) $ mkConstMethod $methodName [] $returnedType"
      else
         echo "just $ mkConstMethod $methodName [] $returnedType"
      fi    
    fi
    ;;
'constructor-method') 

    if [ $defaultsCount -gt 0 ]; then
       if [[ $ifFirstDefault == true ]]; then
         majorVersion="$(cut -d'.' -f1 <<< "$minVersion")"
         minorVersion="$(cut -d'.' -f2 <<< "$minVersion")"
       fi    
       
    else
      if [ ! -z "$minVersion" ]; then
         majorVersion="$(cut -d'.' -f1 <<< "$minVersion")"
         minorVersion="$(cut -d'.' -f2 <<< "$minVersion")"
         echo "test (qtVersion >= [$majorVersion, $minorVersion]) $ mkCtor $methodName []"
      else
         echo "just $ mkCtor $methodName []"
      fi    
    fi
   ;;
*) 
   ;;
   
esac
